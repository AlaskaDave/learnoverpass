<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ens on LearnOverpass</title>
    <link>//osmlab.github.io/learnoverpass/en/</link>
    <description>Recent content in Ens on LearnOverpass</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 06 Jul 2015 16:35:50 +0800</lastBuildDate>
    <atom:link href="//osmlab.github.io/learnoverpass/en/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Filter by Tag III</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/6/</link>
      <pubDate>Mon, 06 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/6/</guid>
      <description>&lt;p&gt;“Woah, great! I see a lot of nodes around me, but there are too many, and I’m not sure which are the restaurants!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;We used the &lt;code&gt;around&lt;/code&gt; filter on our previous example to query for nodes around our particular node, and it worked! As you can see on the map viewer, we see the OSM data around our first statement.&lt;/p&gt;

&lt;p&gt;However, it’s quite problematic - we haven’t actually found any restaurants, and there are too many nodes!&lt;/p&gt;

&lt;p&gt;Again, we will use the concept that we learned earlier to further filter our data. &lt;code&gt;around&lt;/code&gt; gave us a bunch of nodes, so we need to use &lt;em&gt;filter by tag ([k=v])&lt;/em&gt; to filter it to only restaurants.&lt;/p&gt;

&lt;p&gt;Go ahead and combine our &lt;code&gt;around&lt;/code&gt; filter with our &lt;code&gt;by tag&lt;/code&gt; filter!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Around Filter</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/5/</link>
      <pubDate>Sun, 05 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/5/</guid>
      <description>&lt;p&gt;&amp;ldquo;Woah, it’s empty! Could it be that there are no restaurants near me?” asks Bob.&lt;/p&gt;

&lt;p&gt;Not really. See, our first statement &lt;code&gt;node(2190458950)&lt;/code&gt; is &lt;em&gt;already&lt;/em&gt; a node, so filtering it further wouldn’t do anything! And since we added a new filter (restaurants) to a statement that we &lt;strong&gt;know&lt;/strong&gt; gives us a tree, we basically asked OSM to further filter our result set (a tree node) to only show restaurants, which obviously results in OSM nothing (since a tree is not a restaurant)!&lt;/p&gt;

&lt;p&gt;Our previous examples worked because we filtered for nodes with tags present in an &lt;em&gt;area&lt;/em&gt; (the &lt;code&gt;bounding box&lt;/code&gt; with lat/lon points). We essentially queried for nodes in an area, then used filters to filter it down to a tree.&lt;/p&gt;

&lt;p&gt;Right now, since our node is already a node, we can’t just use a filter to get a restaurant from it. We have to get a new &lt;em&gt;area&lt;/em&gt; from the node.&lt;/p&gt;

&lt;p&gt;To do this, we can make great use of another filter, named &lt;code&gt;around&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filter by Tag III?</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/4/</link>
      <pubDate>Sat, 04 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/4/</guid>
      <description>&lt;p&gt;“Well isn’t that better? Shorter and easier to work with.”&lt;/p&gt;

&lt;p&gt;“You know, I’ve been waiting for you for quite a while, I’m hungry! Since my GPS doesn’t really seem to be all that reliable, would you mind looking for a place near me where I can eat?&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filter By Tag II</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/3/</link>
      <pubDate>Fri, 03 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/3/</guid>
      <description>&lt;p&gt;Awesome! We’ve filtered our data to only show trees!&lt;/p&gt;

&lt;p&gt;If you notice on the text editor on the right, [natural=tree] is placed on the 2nd line. Overpass Turbo allows you to add indentation and extra lines as you see fit, so feel free to make ample use of them to make your queries more readable! Note however, that the semicolon is also placed in the second line to tell Overpass that statement is finished. Think of it as Overpass’ period.&lt;/p&gt;

&lt;p&gt;Anyway, we successfully filtered the data to only request for trees. However, we still have a problem. While “Bob” told us he is at a tree, there are THREE trees in the area!&lt;/p&gt;

&lt;p&gt;“Hello! Hello! Query Writer” says Bob.&lt;/p&gt;

&lt;p&gt;Bob: “It seems that we are in quite a predicament here. I’m not sure how I can help, but I do know that I’m next to the tallest tree in the area.”&lt;/p&gt;

&lt;p&gt;Woah, Bob just talked to us, and he mentions being next to the tallest tree! If you notice from the tree nodes, they are also tagged by their height! You can use these to further filter your data!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filter By Tag</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/2/</link>
      <pubDate>Thu, 02 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/2/</guid>
      <description>&lt;p&gt;Nice! As you can see the Query Language might look cryptic at first, but it’s actually quite straightforward!&lt;/p&gt;

&lt;p&gt;Those circles you see in the map view are &amp;ldquo;points of interest&amp;rdquo; called “nodes”. Try clicking on them - some just contain their own positions (lat/lon) but some of them are tagged and contain other data, such as names, type of node, etc, etc.&lt;/p&gt;

&lt;p&gt;Since our friend “Bob” has a pretty inaccurate GPS, he only managed to give us rough coordinates. He DID say that he would be by a tree, however, so why don’t we try searching for a node that’s a tree? He’s bound to be there!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>//osmlab.github.io/learnoverpass/en/exercises/intro/1/</link>
      <pubDate>Wed, 01 Jul 2015 16:35:50 +0800</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/exercises/intro/1/</guid>
      <description>&lt;p&gt;Hello and welcome to LearnOverpass!&lt;/p&gt;

&lt;p&gt;The Overpass API is a powerful API that lets you query data from OpenStreetMap. You can find different places, routes to locations, and everything under the sun, quite literally! You can ‘talk’ to it and request data for your own specific use, using its own language, the “Overpass Query Language” (QL).&lt;/p&gt;

&lt;p&gt;What you see on the right is a text editor where you can type in your QL commands. See the statement with the word &lt;code&gt;node&lt;/code&gt;? That&amp;rsquo;s a QL statement which asks (queries) the API for a single point of interest (a node) in OpenStreetMap.&lt;/p&gt;

&lt;p&gt;The world map below the editor is a visualization of the data that&amp;rsquo;s received by your statement. Right now it contains nothing, because our statement is incomplete - while we &lt;em&gt;query a node&lt;/em&gt; with the first line, it doesn’t know what or which node we’re interested in, so the API doesn&amp;rsquo;t know what to do with it!&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s change that!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Union</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/union/</link>
      <pubDate>Thu, 07 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/union/</guid>
      <description>&lt;p&gt;The union block statement is written as a pair of parentheses. Inside the union, any sequence of statements can be placed, including nested union and foreach statements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(statement_1; statement_2; …)[-&amp;gt;.result_set];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes no input set. It produces a result set. Its result set is the union of the result sets of all sub-statements, regardless of whether a sub-statement has a redirected result set or not.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;];way[name=&amp;quot;Foo&amp;quot;];);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This collects in the first statement all nodes that have a name tag &amp;ldquo;Foo&amp;rdquo; and in the second statement all ways that have a name tag &amp;ldquo;Foo&amp;rdquo;. After the union statement, the result set is the union of the result sets of both statements.&lt;/p&gt;

&lt;p&gt;The result set of the union statement can be redirected with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;];way[name=&amp;quot;Foo&amp;quot;];)-&amp;gt;.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same as the preceding example, but the result is written into the variable a.&lt;/p&gt;

&lt;p&gt;Note: foreach and print statements cannot be subelement of element union.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(
node
  [amenity=drinking_water]
  (47.06,15.42,47.09,15.48);
node
  [tourism=hotel]
  (47.06,15.42,47.09,15.48);
);
out;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%28%0anode%0a%20%20%5bamenity%3ddrinking_water%5d%0a%20%20%2847.06%2c15.42%2c47.09%2c15.48%29%3b%0anode%0a%20%20%5btourism%3dhotel%5d%0a%20%20%2847.06%2c15.42%2c47.09%2c15.48%29%3b%0a%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Difference</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/difference/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/difference/</guid>
      <description>&lt;p&gt;The difference block statement is written as a pair of parentheses. Inside the difference statement, exactly two statements must be placed, and between them a minus sign.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(statement_1; - statement_2;)[-&amp;gt;.result_set];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes no input set. It produces a result set. Its result set contains all elements that are result of the first sub-statement and not contained in the result of the second sub-statement.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;]; - node(50.0,7.0,51.0,8.0););
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This collects all nodes that have a name tag &amp;ldquo;Foo&amp;rdquo; but are not inside the given bounding box.&lt;/p&gt;

&lt;p&gt;The result set of the difference statement can be redirected with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;]; - node(50.0,7.0,51.0,8.0);)-&amp;gt;.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same as the preceding example, but the result is written into the variable a.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(
node[amenity]( 47.06, 15.435,  47.07,  15.44);
-node[amenity](47.064, 15.435, 47.066, 15.44);
);
out;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%28%0anode%5bamenity%5d%28%2047.06%2c%2015.435%2c%20%2047.07%2c%20%2015.44%29%3b%0a-node%5bamenity%5d%2847.064%2c%2015.435%2c%2047.066%2c%2015.44%29%3b%0a%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>For-each loop (foreach)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/foreach/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/foreach/</guid>
      <description>&lt;p&gt;The foreach block statement is written as the keyword foreach, followed by a pair of parentheses. Inside these parentheses, any sequence of statements can be placed, including nested union and foreach statements.&lt;/p&gt;

&lt;p&gt;It takes an input set. It produces no result set. The foreach statement loops over the content of the input set, once for every element in the input set.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way[name=&amp;quot;Foo&amp;quot;];
foreach(
  (
    ._;
    &amp;gt;;
  );
  out;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each way that has a name tag with value &amp;ldquo;Foo&amp;rdquo;, this prints the nodes that belong to this way immediately followed by the way itself. In detail, the result set of way[name=&amp;ldquo;Foo&amp;rdquo;] is taken as input set. Then, for each element in this input set the loop body is executed once. Inside the loop body the union of the element and its nodes is taken. Then this union is printed. Note that during execution, each printed subset in an iteration is independant of subsets printed in other iterations, possibly resulting in duplicate objects in the global output (no union is computed by the out statement within the loop).&lt;/p&gt;

&lt;p&gt;The input set of the foreach statement can be taken from a variable with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach.a(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loops over the content of set a instead of the default set &amp;ldquo;_&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The name of the variable to put the loop element into can also be chosen by adding a postfix immediately before the opening parenthese.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach-&amp;gt;.b(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This puts the element to loop over into the variable b. Without it, the foreach statement does not puts the elements into any set. Example for both input and loop set changed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach.a-&amp;gt;.b(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get all bank nodes in coordinates
(
  node[amenity=bank]
  (47.0678,15.4401658,47.069,15.4501658);
  &amp;gt;;
);
// foreach bank node, print out adjacent nodes
foreach-&amp;gt;.bank_set(
  node(around.bank_set:15)-&amp;gt;.adjacent_set;
  (.adjacent_set);
  out meta;
);
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%2f%2f%20get%20all%20bank%20nodes%20in%20coordinates%0a%28%0a%20%20node%5bamenity%3dbank%5d%0a%20%20%2847.0678%2c15.4401658%2c47.069%2c15.4501658%29%3b%0a%20%20%3e%3b%0a%29%3b%0a%2f%2f%20foreach%20bank%20node%2c%20print%20out%20adjacent%20nodes%0aforeach-%3e.bank_set%28%0a%20%20node%28around.bank_set%3a15%29-%3e.adjacent_set%3b%0a%20%20%28.adjacent_set%29%3b%0a%20%20out%20meta%3b%0a%29%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overpass API Documentation</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/</guid>
      <description>&lt;p&gt;Overpass QL is the second query language for the Overpass API and was designed as an alternative to Overpass XML. It has a C style syntax: The whole query source code is divided in statements, and every statement ends with a semicolon. It has imperative semantics: The statements are processed one after another and change the execution state according to their semantics.&lt;/p&gt;

&lt;p&gt;The execution state consists of the default set, potentially other named sets, and for block statements a stack. A set can contain nodes, ways, relations and areas, also of mixed type and of any number. Sets are created as result sets of statements and are read by subsequent statements as input. Unless you specify a named set as input or result, all input is implicitly read from and all results are written to the default variable named _ (a single underscore). Names for sets may consist of letters, digits and the underscore but must not start with a digit. Once a new result is (implicitly or explicitly) assigned to an existing set, its previous contents will be replaced and are no longer available. Sets always have global visibility.&lt;/p&gt;

&lt;p&gt;There are several different types of statement. You almost always need the print statement, which is called an action, because it has an effect outside the execution state (the output). The other statements are grouped into&lt;/p&gt;

&lt;p&gt;Standalone queries: These are complete statements on their own.
Filters: They are always part of a query statement and contain the interesting selectors and filters.
Block statements: They group statements and enable disjunctions as well as loops.
Settings: Things like output format that can be set once at the beginning.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overpass API is a highly optimized, read-only API built for gathering OSM map data.</title>
      <link>//osmlab.github.io/learnoverpass/en/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/</guid>
      <description>&lt;p&gt;Whether you are a complete beginner or an established developer, you will find LearnOverpass as the most comprehensive resource to learn how to utilize the Overpass API. In short time, learn how to use the powerful Query language, and collect data of various criteria: from location, types of objects, tag properties to proximities.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Area pivot (pivot)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/pivot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/pivot/</guid>
      <description>&lt;p&gt;The &lt;em&gt;pivot&lt;/em&gt; filter selects the element of the chosen type that defines the outline of the given area.&lt;/p&gt;

&lt;p&gt;The input set can be changed with an adapted prefix notation. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows the keyword &lt;em&gt;pivot&lt;/em&gt;. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;The statement finds for each area in the input set the respective element that the area has been generated from. Which is either a multipolygon relation or a way.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way(pivot);
rel(pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example with modified input set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way(pivot.a);
rel(pivot.a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// determine area for Greater London and store it to .London_area
area[name=&amp;#34;London&amp;#34;][admin_level=6][boundary=administrative]-&amp;gt;.London_area;
// convert back to relations using the pivot filter
rel(pivot.London_area);
// output the geom
out geom;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%2f%2f%20determine%20area%20for%20Greater%20London%20and%20store%20it%20to%20.London_area%0aarea%5bname%3d%22London%22%5d%5badmin_level%3d6%5d%5bboundary%3dadministrative%5d-%3e.London_area%3b%0a%2f%2f%20convert%20back%20to%20relations%20using%20the%20pivot%20filter%0arel%28pivot.London_area%29%3b%0a%2f%2f%20output%20the%20geom%0aout%20geom%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bounding Box</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/bbox/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/bbox/</guid>
      <description>&lt;p&gt;The bbox-query filter selects all elements within a certain bounding box.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(south,west,north,east)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follow four floating point numbers, separated by commas. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;The floating point numbers give the limits of the bounding box: The first is the southern limit or minimum latitude. The second is the western limit, usually the minimum longitude. The third is the northern limit or maximum latitude. The last is the eastern limit, usually the maximum longitude. If the second argument is bigger than the fourth argument, the bounding box crosses the longitude of 180 degrees.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
node
(47.065,15.425,47.07,15.43); // a bbox-filter
out;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0anode%0a%2847.065%2c15.425%2c47.07%2c15.43%29%3b%20%2f%2f%20a%20bbox-filter%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By Element Id</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/element-id/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/element-id/</guid>
      <description>&lt;p&gt;The id-query filter selects the element of given type with given id. It supports beside the OSM datatypes node, way, and relation also the type area.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows a positive integer. The filter is ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(1);
way(1);
rel(1);
area(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that area ids need to be derived from an existing OSM way by adding 2400000000 to its OSM id or in case of a relation by adding 3600000000 respectively. Note that area creation is subject to some extraction rules, i.e. not all ways/relations have an area counterpart. See &lt;a href=&#34;https://github.com/drolbr/Overpass-API/blob/master/rules/areas.osm3s&#34;&gt;areas.osm3s&lt;/a&gt; for details.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get node with id 1170494282
// put it (implicitly) in the default set
node(1170494282);
// print the default set
out;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%2f%2f%20get%20node%20with%20id%201170494282%0a%2f%2f%20put%20it%20%28implicitly%29%20in%20the%20default%20set%0anode%281170494282%29%3b%0a%2f%2f%20print%20the%20default%20set%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By Input Set</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/input-set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/input-set/</guid>
      <description>&lt;p&gt;The &amp;ldquo;item&amp;rdquo; filter selects all elements from its input set.&lt;/p&gt;

&lt;p&gt;As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of a dot, followed by the name of the input set.&lt;/p&gt;

&lt;p&gt;Examples: The default set&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node._;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a named set&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to specify several input sets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.a.b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get area Alpe and Cividale
(area[name=&amp;#34;Cividale del Friuli&amp;#34;])-&amp;gt;.Cividale;
(area[name=&amp;#34;Julijske Alpe&amp;#34;])-&amp;gt;.Alpe;

(node[power=pole](area.Cividale))-&amp;gt;.Cividale_nodes;
(node[power=pole](area.Alpe))-&amp;gt;.Alpe_nodes;

// print out nodes that are present in both areas (intersection)
node.Alpe_nodes.Cividale_nodes;
out body qt;

(relation[name=&amp;#34;Cividale del Friuli&amp;#34;];&amp;gt;;);
out body;
out skel qt;

(relation[name=&amp;#34;Julijske Alpe&amp;#34;];&amp;gt;;);
out body;
out skel qt;
&lt;/textarea&gt;&lt;div class=&#34;docs-repl-result&#34;&gt;  &lt;iframe src=&#34;http://overpass-turbo.eu/master/map.html?Q=%0a%2f%2f%20get%20area%20Alpe%20and%20Cividale%0a%28area%5bname%3d%22Cividale%20del%20Friuli%22%5d%29-%3e.Cividale%3b%0a%28area%5bname%3d%22Julijske%20Alpe%22%5d%29-%3e.Alpe%3b%0a%0a%28node%5bpower%3dpole%5d%28area.Cividale%29%29-%3e.Cividale_nodes%3b%0a%28node%5bpower%3dpole%5d%28area.Alpe%29%29-%3e.Alpe_nodes%3b%0a%0a%2f%2f%20print%20out%20nodes%20that%20are%20present%20in%20both%20areas%20%28intersection%29%0anode.Alpe_nodes.Cividale_nodes%3b%0aout%20body%20qt%3b%0a%0a%28relation%5bname%3d%22Cividale%20del%20Friuli%22%5d%3b%3e%3b%29%3b%0aout%20body%3b%0aout%20skel%20qt%3b%0a%0a%28relation%5bname%3d%22Julijske%20Alpe%22%5d%3b%3e%3b%29%3b%0aout%20body%3b%0aout%20skel%20qt%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34;&gt;&lt;/iframe&gt;&lt;textarea&gt;&lt;/textarea&gt; &lt;a class=&#34;docs-repl-change-output button&#34; href=&#34;#&#34;&gt;Data&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>