<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LearnOverpass</title>
    <link>//osmlab.github.io/learnoverpass/</link>
    <description>Recent content on LearnOverpass</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 May 2015 11:09:35 +0000</lastBuildDate>
    <atom:link href="//osmlab.github.io/learnoverpass/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Union</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/union/</link>
      <pubDate>Thu, 07 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/union/</guid>
      <description>&lt;p&gt;The union block statement is written as a pair of parentheses. Inside the union, any sequence of statements can be placed, including nested union and foreach statements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(statement_1; statement_2; â€¦)[-&amp;gt;.result_set];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes no input set. It produces a result set. Its result set is the union of the result sets of all sub-statements, regardless of whether a sub-statement has a redirected result set or not.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;];way[name=&amp;quot;Foo&amp;quot;];);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This collects in the first statement all nodes that have a name tag &amp;ldquo;Foo&amp;rdquo; and in the second statement all ways that have a name tag &amp;ldquo;Foo&amp;rdquo;. After the union statement, the result set is the union of the result sets of both statements.&lt;/p&gt;

&lt;p&gt;The result set of the union statement can be redirected with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;];way[name=&amp;quot;Foo&amp;quot;];)-&amp;gt;.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same as the preceding example, but the result is written into the variable a.&lt;/p&gt;

&lt;p&gt;Note: foreach and print statements cannot be subelement of element union.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(
node
  [amenity=drinking_water]
  (47.06,15.42,47.09,15.48);
node
  [tourism=hotel]
  (47.06,15.42,47.09,15.48);
);
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%28%0anode%0a%20%20%5bamenity%3ddrinking_water%5d%0a%20%20%2847.06%2c15.42%2c47.09%2c15.48%29%3b%0anode%0a%20%20%5btourism%3dhotel%5d%0a%20%20%2847.06%2c15.42%2c47.09%2c15.48%29%3b%0a%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>For-each loop (foreach)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/foreach/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/foreach/</guid>
      <description>&lt;p&gt;The foreach block statement is written as the keyword foreach, followed by a pair of parentheses. Inside these parentheses, any sequence of statements can be placed, including nested union and foreach statements.&lt;/p&gt;

&lt;p&gt;It takes an input set. It produces no result set. The foreach statement loops over the content of the input set, once for every element in the input set.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way[name=&amp;quot;Foo&amp;quot;];
foreach(
  (
    ._;
    &amp;gt;;
  );
  out;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each way that has a name tag with value &amp;ldquo;Foo&amp;rdquo;, this prints the nodes that belong to this way immediately followed by the way itself. In detail, the result set of way[name=&amp;ldquo;Foo&amp;rdquo;] is taken as input set. Then, for each element in this input set the loop body is executed once. Inside the loop body the union of the element and its nodes is taken. Then this union is printed. Note that during execution, each printed subset in an iteration is independant of subsets printed in other iterations, possibly resulting in duplicate objects in the global output (no union is computed by the out statement within the loop).&lt;/p&gt;

&lt;p&gt;The input set of the foreach statement can be taken from a variable with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach.a(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loops over the content of set a instead of the default set &amp;ldquo;_&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The name of the variable to put the loop element into can also be chosen by adding a postfix immediately before the opening parenthese.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach-&amp;gt;.b(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This puts the element to loop over into the variable b. Without it, the foreach statement does not puts the elements into any set. Example for both input and loop set changed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach.a-&amp;gt;.b(...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get all bank nodes in coordinates
(
  node[amenity=bank]
  (47.0678,15.4401658,47.069,15.4501658);
  &amp;gt;;
);
// foreach bank node, print out adjacent nodes
foreach-&amp;gt;.bank_set(
  node(around.bank_set:15)-&amp;gt;.adjacent_set;
  (.adjacent_set);
  out meta;
);
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20get%20all%20bank%20nodes%20in%20coordinates%0a%28%0a%20%20node%5bamenity%3dbank%5d%0a%20%20%2847.0678%2c15.4401658%2c47.069%2c15.4501658%29%3b%0a%20%20%3e%3b%0a%29%3b%0a%2f%2f%20foreach%20bank%20node%2c%20print%20out%20adjacent%20nodes%0aforeach-%3e.bank_set%28%0a%20%20node%28around.bank_set%3a15%29-%3e.adjacent_set%3b%0a%20%20%28.adjacent_set%29%3b%0a%20%20out%20meta%3b%0a%29%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Difference</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/block-queries/difference/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/block-queries/difference/</guid>
      <description>&lt;p&gt;The difference block statement is written as a pair of parentheses. Inside the difference statement, exactly two statements must be placed, and between them a minus sign.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(statement_1; - statement_2;)[-&amp;gt;.result_set];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It takes no input set. It produces a result set. Its result set contains all elements that are result of the first sub-statement and not contained in the result of the second sub-statement.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;]; - node(50.0,7.0,51.0,8.0););
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This collects all nodes that have a name tag &amp;ldquo;Foo&amp;rdquo; but are not inside the given bounding box.&lt;/p&gt;

&lt;p&gt;The result set of the difference statement can be redirected with the usual postfix notation:&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(node[name=&amp;quot;Foo&amp;quot;]; - node(50.0,7.0,51.0,8.0);)-&amp;gt;.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same as the preceding example, but the result is written into the variable a.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(
node[amenity]( 47.06, 15.435,  47.07,  15.44);
-node[amenity](47.064, 15.435, 47.066, 15.44);
);
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%28%0anode%5bamenity%5d%28%2047.06%2c%2015.435%2c%20%2047.07%2c%20%2015.44%29%3b%0a-node%5bamenity%5d%2847.064%2c%2015.435%2c%2047.066%2c%2015.44%29%3b%0a%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overpass API is a highly optimized, read-only API built for gathering OSM map data.</title>
      <link>//osmlab.github.io/learnoverpass/de/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/de/</guid>
      <description>&lt;p&gt;Currently untranslated&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overpass API Documentation</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/</guid>
      <description>&lt;p&gt;Overpass QL is the second query language for the Overpass API and was designed as an alternative to Overpass XML. It has a C style syntax: The whole query source code is divided in statements, and every statement ends with a semicolon. It has imperative semantics: The statements are processed one after another and change the execution state according to their semantics.&lt;/p&gt;

&lt;p&gt;The execution state consists of the default set, potentially other named sets, and for block statements a stack. A set can contain nodes, ways, relations and areas, also of mixed type and of any number. Sets are created as result sets of statements and are read by subsequent statements as input. Unless you specify a named set as input or result, all input is implicitly read from and all results are written to the default variable named _ (a single underscore). Names for sets may consist of letters, digits and the underscore but must not start with a digit. Once a new result is (implicitly or explicitly) assigned to an existing set, its previous contents will be replaced and are no longer available. Sets always have global visibility.&lt;/p&gt;

&lt;p&gt;There are several different types of statement. You almost always need the print statement, which is called an action, because it has an effect outside the execution state (the output). The other statements are grouped into&lt;/p&gt;

&lt;p&gt;Standalone queries: These are complete statements on their own.
Filters: They are always part of a query statement and contain the interesting selectors and filters.
Block statements: They group statements and enable disjunctions as well as loops.
Settings: Things like output format that can be set once at the beginning.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Overpass API is a highly optimized, read-only API built for gathering OSM map data.</title>
      <link>//osmlab.github.io/learnoverpass/en/</link>
      <pubDate>Wed, 06 May 2015 11:09:35 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/</guid>
      <description>&lt;p&gt;Whether you are a complete beginner or an established developer, you will find LearnOverpass as the most comprehensive resource to learn how to utilize the Overpass API. In short time, learn how to use the powerful Query language, and collect data of various criteria: from location, types of objects, tag properties to proximities.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Print (out)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/actions/print/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/actions/print/</guid>
      <description>&lt;p&gt;The out action can be configured with an arbitrary number of parameters that are appended, separated by whitespace, between the word out and the semicolon.&lt;/p&gt;

&lt;p&gt;The out action takes an input set. It doesn&amp;rsquo;t return a result set. The input set can be changed by prepending the variable name.&lt;/p&gt;

&lt;p&gt;Allowed values, in any order, are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;one of the following the degree of verbosity; default is body:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;ids&lt;/em&gt;: Print only the ids of the elements.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;skel&lt;/em&gt;: Print also the information necessary for geometry. These are also coordinates for nodes and way and relation member ids for ways and relations.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;body&lt;/em&gt;: Print all information necessary to use the data. These are also tags for all elements and the roles for relation members.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;tags&lt;/em&gt;: Print only ids and tags for each element and not coordinates or members.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;meta&lt;/em&gt;: Print everything known about the elements. This includes additionally to body for all elements the version, changeset id, timestamp and the user data of the user that last touched the object.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;one of the following modificators for derived information:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;bb&lt;/em&gt;: Adds the bounding box of each element to the element. For nodes this is equivalent to &amp;ldquo;geom&amp;rdquo;. For ways it is the enclosing bounding box of all nodes. For relations it is the enclosing bounding box of all node and way members, relations as members have no effect.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;center&lt;/em&gt;: This adds the center of the above mentioned bounding box to ways and relations. Note: The center point is not guaranteed to lie inside the polygon (example).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;geom&lt;/em&gt;: Add the full geometry to each object. This adds coordinates to each node, to each node member of a way or relation, and it adds a sequence of &amp;ldquo;nd&amp;rdquo; members with coordinates to all relations.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The attribute &amp;ldquo;geom&amp;rdquo; can be followed by a bounding box in the format &amp;ldquo;(south,west,north,east)&amp;rdquo;. In this case only coordinates that are inside the bounding box are produced. For way segments also the first coordinate outside the bounding box is produced to allow for properly formed segments.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One of the following for the sort order can be added. Default is asc.

&lt;ul&gt;
&lt;li&gt;asc: Sort by object id.&lt;/li&gt;
&lt;li&gt;qt: Sort by quadtile index; this is roughly geographical and significantly faster than order by ids.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;a non-negative integer for the maximum number of elements to print. Default is no limit.
Example:&lt;/p&gt;

&lt;p&gt;out;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Print the elements without meta information.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;out meta;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Print the elements with meta information.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;out 99;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Print at most 99 elements.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;out meta qt 1000000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Print up to 1,000,000 elements, ordered by location, with meta data.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.a out;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reads from variable a the data to output.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;select&gt;&lt;/select&gt; &lt;textarea&gt;===default===
(
  // Rio de Janeiro&amp;#39;s Christ the Redeemer peak
  node[name=Corcovado][natural=peak];
  &amp;gt;;
);
out;
===meta===
(
  // Rio de Janeiro&amp;#39;s Christ the Redeemer peak
  node[name=Corcovado][natural=peak];
  &amp;gt;;
);
out meta;
&lt;/textarea&gt;&lt;iframe  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By area (area)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/area/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/area/</guid>
      <description>&lt;p&gt;The area filter selects all elements of the chosen type that are inside the given area. Please note with regard to attic data that areas always represent current data.&lt;/p&gt;

&lt;p&gt;The input set can be changed with an adapted prefix notation. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;Syntax: It consists of an opening parenthesis. Then follows the keyword area. Then can follow a colon and a non-negative integer. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Nodes are found if they are properly inside or on the border of the area. Ways are found if at least one point (also points on the segment) is properly inside the area. A way ending on the border and not otherwise crossing the area is not found. Relations are found if one of its members is properly inside the area.&lt;/p&gt;

&lt;p&gt;If the area statement is provided without integer, the areas from the input set are used. An Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(area);
way(area);
rel(area);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example with modified input set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(area.a);
way(area.a);
rel(area.a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an integer is added, the input set is ignored and instead the area that has the given integer as id is taken.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(area:2400000001);
way(area:2400000001);
rel(area:2400000001);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because areas in OSM are not native elements but are only infered from the OSM database using its closed ways or relations; this facility allows grouping their various representation in a coherent set which can store their geometry, independantly of their complexity and representation in the OSM database, as if they were a single distinctive element, without using complex filtering rules in your query. However associating these objects with an OSM id attribute requires some adjusment because the same id value could be used for unrelated elements with different type (way or relation). For this reason, areas returned by the Overpass API only have a &amp;ldquo;virtual&amp;rdquo; id specific to the Overpass API, but not found directly in the OSM database.&lt;/p&gt;

&lt;p&gt;By convention the area id can be calculated from an existing OSM way by adding 2400000000 to its OSM id, or in case of a relation by adding 3600000000 respectively. Note that area creation is subject to some extraction rules, i.e. not all ways/relations have an area counterpart (notably those that are tagged with &lt;code&gt;area=no&lt;/code&gt;, and most multipolygons and that don&amp;rsquo;t have a defined &lt;code&gt;name=*&lt;/code&gt; will not be part of areas).
Areas are created by a regular job on the Overpass API server and usually have a lag of several hours compared to the OSM main database. The exact timestamp can be determined by checking the &lt;code&gt;timestamp_areas_base&lt;/code&gt; value in the Overpass json or xml result.&lt;/p&gt;

&lt;p&gt;If you want more immediate results (not depending on the delayed batch processing), you can also write your own filters without using this facility in your Overpass query: use standard OSM element types and ids and filter them by specific tags of your choice.&lt;/p&gt;

&lt;p&gt;See &lt;a href=&#34;https://github.com/drolbr/Overpass-API/blob/master/rules/areas.osm3s&#34;&gt;areas.osm3s&lt;/a&gt; for details of the filters (written using the XML variant of the Overpass query language) currently by Overpass used to generate the areas that can be queried with this facility. Those areas are defined using the &amp;ldquo;pivot&amp;rdquo; query feature.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// search the area of the Dolmites
area
  [place=region]
  [&amp;#34;region:type&amp;#34;=&amp;#34;mountain_area&amp;#34;]
  [&amp;#34;name:en&amp;#34;=&amp;#34;Dolomites&amp;#34;];
out body;

// get all peaks in the area
node
  [natural=peak]
  (area);
out body qt;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20search%20the%20area%20of%20the%20Dolmites%0aarea%0a%20%20%5bplace%3dregion%5d%0a%20%20%5b%22region%3atype%22%3d%22mountain_area%22%5d%0a%20%20%5b%22name%3aen%22%3d%22Dolomites%22%5d%3b%0aout%20body%3b%0a%0a%2f%2f%20get%20all%20peaks%20in%20the%20area%0anode%0a%20%20%5bnatural%3dpeak%5d%0a%20%20%28area%29%3b%0aout%20body%20qt%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Relative to other elements (around)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/around/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/around/</guid>
      <description>&lt;p&gt;The around filter selects all elements within a certain radius around the elements in the input set. If you provide coordinates, then these coordinates are used instead of the input set. The input set can be changed with an adapted prefix notation. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;A radius of 0 can be used for a way intersection test on outer/inner points.&lt;/p&gt;

&lt;p&gt;Syntax: It consists of an opening parenthesis. Then follows the keyword around. Then follows optionally an input set declaration. Then follows a single floating point number that denotes the radius in meters. The filter either ends with a closing parenthesis or is followed by two comma separated floating point numbers indicating latitude and longitude and then finally a closing parenthesis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(around[.input_set]:radius)
(around:radius,latitude,longitude)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(around:100.0);
way(around:100.0);
rel(around:100.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example with modified input set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(around.a:100.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Examples with coordinates:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(around:100.0,50.7,7.1);
way(around:100.0,50.7,7.1);
rel(around:100.0,50.7,7.1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example: Find all cinemas in Bonn which are at most 100m away from bus stops&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;area[name=&amp;quot;Bonn&amp;quot;];
node(area)[highway=bus_stop];
node(around:100)[amenity=cinema];
out;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get all ways from a 50m radius from
// coordinates 51.1788435, -1.826204 (stonehenge)
(way(around:50, 51.1788435,-1.826204);&amp;gt;;);
out body;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20get%20all%20ways%20from%20a%2050m%20radius%20from%0a%2f%2f%20coordinates%2051.1788435%2c%20-1.826204%20%28stonehenge%29%0a%28way%28around%3a50%2c%2051.1788435%2c-1.826204%29%3b%3e%3b%29%3b%0aout%20body%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bounding Box</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/bbox/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/bbox/</guid>
      <description>&lt;p&gt;The bbox-query filter selects all elements within a certain bounding box.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(south,west,north,east)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follow four floating point numbers, separated by commas. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;The floating point numbers give the limits of the bounding box: The first is the southern limit or minimum latitude. The second is the western limit, usually the minimum longitude. The third is the northern limit or maximum latitude. The last is the eastern limit, usually the maximum longitude. If the second argument is bigger than the fourth argument, the bounding box crosses the longitude of 180 degrees.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
node
(47.065,15.425,47.07,15.43); // a bbox-filter
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0anode%0a%2847.065%2c15.425%2c47.07%2c15.43%29%3b%20%2f%2f%20a%20bbox-filter%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By date of change (changed)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/changed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/changed/</guid>
      <description>&lt;p&gt;The changed filter selects all elements that have been changed between the two given dates. If only one date is given, then the second is assumed to be the front date of the database. If only one date is given and it is run with the current timestamp, then it behaves exactly like &amp;ldquo;newer&amp;rdquo; with two exceptions: first, it is faster, second, it can also stand as the only filter.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows a date specification. Please note that this date specification cannot be abbreviated and has to be put in single or double quotes. Then can follow a comma and a second date specification. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Example: All changes since the given date and now&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node._(changed:&amp;quot;2012-09-14T07:00:00Z&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(node(poly:&amp;#34;50.73 7.13 50.73 7.17 50.75 7.15&amp;#34;);&amp;gt;;);
// This finds all nodes that have changed
// between the two given dates 
node._(changed:&amp;#34;2012-09-14T07:00:00Z&amp;#34;,&amp;#34;2012-09-14T07:01:00Z&amp;#34;);
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%28node%28poly%3a%2250.73%207.13%2050.73%207.17%2050.75%207.15%22%29%3b%3e%3b%29%3b%0a%2f%2f%20This%20finds%20all%20nodes%20that%20have%20changed%0a%2f%2f%20between%20the%20two%20given%20dates%20%0anode._%28changed%3a%222012-09-14T07%3a00%3a00Z%22%2c%222012-09-14T07%3a01%3a00Z%22%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By Element Id</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/element-id/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/element-id/</guid>
      <description>&lt;p&gt;The id-query filter selects the element of given type with given id. It supports beside the OSM datatypes node, way, and relation also the type area.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows a positive integer. The filter is ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node(1);
way(1);
rel(1);
area(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that area ids need to be derived from an existing OSM way by adding 2400000000 to its OSM id or in case of a relation by adding 3600000000 respectively. Note that area creation is subject to some extraction rules, i.e. not all ways/relations have an area counterpart. See &lt;a href=&#34;https://github.com/drolbr/Overpass-API/blob/master/rules/areas.osm3s&#34;&gt;areas.osm3s&lt;/a&gt; for details.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get node with id 1170494282
// put it (implicitly) in the default set
node(1170494282);
// print the default set
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20get%20node%20with%20id%201170494282%0a%2f%2f%20put%20it%20%28implicitly%29%20in%20the%20default%20set%0anode%281170494282%29%3b%0a%2f%2f%20print%20the%20default%20set%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>By Input Set</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/input-set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/input-set/</guid>
      <description>&lt;p&gt;The &amp;ldquo;item&amp;rdquo; filter selects all elements from its input set.&lt;/p&gt;

&lt;p&gt;As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of a dot, followed by the name of the input set.&lt;/p&gt;

&lt;p&gt;Examples: The default set&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node._;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and a named set&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is also possible to specify several input sets:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node.a.b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// get area Alpe and Cividale
(area[name=&amp;#34;Cividale del Friuli&amp;#34;])-&amp;gt;.Cividale;
(area[name=&amp;#34;Julijske Alpe&amp;#34;])-&amp;gt;.Alpe;

(node[power=pole](area.Cividale))-&amp;gt;.Cividale_nodes;
(node[power=pole](area.Alpe))-&amp;gt;.Alpe_nodes;

// print out nodes that are present in both areas (intersection)
node.Alpe_nodes.Cividale_nodes;
out body qt;

(relation[name=&amp;#34;Cividale del Friuli&amp;#34;];&amp;gt;;);
out body;
out skel qt;

(relation[name=&amp;#34;Julijske Alpe&amp;#34;];&amp;gt;;);
out body;
out skel qt;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20get%20area%20Alpe%20and%20Cividale%0a%28area%5bname%3d%22Cividale%20del%20Friuli%22%5d%29-%3e.Cividale%3b%0a%28area%5bname%3d%22Julijske%20Alpe%22%5d%29-%3e.Alpe%3b%0a%0a%28node%5bpower%3dpole%5d%28area.Cividale%29%29-%3e.Cividale_nodes%3b%0a%28node%5bpower%3dpole%5d%28area.Alpe%29%29-%3e.Alpe_nodes%3b%0a%0a%2f%2f%20print%20out%20nodes%20that%20are%20present%20in%20both%20areas%20%28intersection%29%0anode.Alpe_nodes.Cividale_nodes%3b%0aout%20body%20qt%3b%0a%0a%28relation%5bname%3d%22Cividale%20del%20Friuli%22%5d%3b%3e%3b%29%3b%0aout%20body%3b%0aout%20skel%20qt%3b%0a%0a%28relation%5bname%3d%22Julijske%20Alpe%22%5d%3b%3e%3b%29%3b%0aout%20body%3b%0aout%20skel%20qt%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Newer</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/newer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/newer/</guid>
      <description>&lt;p&gt;The newer filter selects all elements that have been changed since the given date. As opposed to other filters, this filter cannot be used alone. If the underlying database instance supports attic data, then &amp;ldquo;changed&amp;rdquo; is probably a better choice than &amp;ldquo;newer&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;It has no input set. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows a date specification. Please note that this date specification cannot be abbreviated and has to be put in single or double quotes. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
(node(poly:&amp;#34;50.73 7.13 50.73 7.17 50.75 7.15&amp;#34;);&amp;gt;;);
// This finds all nodes that have changed
// since 14 Sep 2012, 7 h UTC, in the given input set.
(node._(newer:&amp;#34;2012-09-14T07:00:00Z&amp;#34;);&amp;gt;;);
out;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%28node%28poly%3a%2250.73%207.13%2050.73%207.17%2050.75%207.15%22%29%3b%3e%3b%29%3b%0a%2f%2f%20This%20finds%20all%20nodes%20that%20have%20changed%0a%2f%2f%20since%2014%20Sep%202012%2c%207%20h%20UTC%2c%20in%20the%20given%20input%20set.%0a%28node._%28newer%3a%222012-09-14T07%3a00%3a00Z%22%29%3b%3e%3b%29%3b%0aout%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Area pivot (pivot)</title>
      <link>//osmlab.github.io/learnoverpass/en/docs/filters/pivot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//osmlab.github.io/learnoverpass/en/docs/filters/pivot/</guid>
      <description>&lt;p&gt;The &lt;em&gt;pivot&lt;/em&gt; filter selects the element of the chosen type that defines the outline of the given area.&lt;/p&gt;

&lt;p&gt;The input set can be changed with an adapted prefix notation. As for all filters, the result set is specified by the whole statement, not the individual filter.&lt;/p&gt;

&lt;p&gt;It consists of an opening parenthesis. Then follows the keyword &lt;em&gt;pivot&lt;/em&gt;. The filter ends with a closing parenthesis.&lt;/p&gt;

&lt;p&gt;The statement finds for each area in the input set the respective element that the area has been generated from. Which is either a multipolygon relation or a way.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way(pivot);
rel(pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example with modified input set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;way(pivot.a);
rel(pivot.a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;div class=&#34;docs-repl&#34;&gt;  &lt;textarea&gt;
// determine area for Greater London and store it to .London_area
area[name=&amp;#34;London&amp;#34;][admin_level=6][boundary=administrative]-&amp;gt;.London_area;
// convert back to relations using the pivot filter
rel(pivot.London_area);
// output the geom
out geom;
&lt;/textarea&gt;&lt;iframe src=&#34;http://overpass-turbo.eu/map.html?Q=%0a%2f%2f%20determine%20area%20for%20Greater%20London%20and%20store%20it%20to%20.London_area%0aarea%5bname%3d%22London%22%5d%5badmin_level%3d6%5d%5bboundary%3dadministrative%5d-%3e.London_area%3b%0a%2f%2f%20convert%20back%20to%20relations%20using%20the%20pivot%20filter%0arel%28pivot.London_area%29%3b%0a%2f%2f%20output%20the%20geom%0aout%20geom%3b%0a&#34;  seamless=&#34;seamless&#34; frameBorder=&#34;0&#34; width=&#34;100%;&#34; style=&#34;height:50vh&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>